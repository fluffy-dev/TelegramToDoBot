# ToDo List Telegram Bot (Django + Aiogram)

Этот проект представляет собой комплексную систему для управления задачами (ToDo List) через Telegram-бота. Бэкенд реализован на Django, а бот — на Aiogram. Весь проект упакован в Docker для легкого развертывания.

## Архитектура решения

- **Backend (Django & DRF):** Является "мозгом" системы и единственным источником правды (single source of truth). Реализует всю бизнес-логику по управлению задачами и категориями, используя архитектурный паттерн "Services/Selectors" для четкого разделения ответственности. Предоставляет REST API для взаимодействия с клиентами.

- **Telegram Bot (Aiogram & Aiogram-Dialog):** Выступает в роли "тонкого клиента" и пользовательского интерфейса. Вся работа с данными происходит через вызовы API бэкенда. Для хранения сессионных данных (токенов аутентификации) используется Redis. Для создания и редактирования задач реализованы многошаговые диалоги.

- **Асинхронные задачи (Celery):** Периодическая проверка просроченных задач и отправка уведомлений вынесены в Celery Beat и Celery Worker, чтобы не нагружать основной цикл приложения. Уведомления доставляются пользователю через механизм webhook, который вызывает бот.

- **Инфраструктура (Docker):** Все компоненты системы (база данных PostgreSQL 16, Redis, Django-приложение, Celery, бот) изолированы в Docker-контейнерах и управляются через `docker-compose.yml`. Это обеспечивает простоту развертывания, переносимость и консистентность окружения.

## Инструкция по запуску проекта

1.  **Клонируйте репозиторий:**
    ```bash
    git clone https://github.com/fluffy-dev/TelegramToDoBot.git
    cd ToDoListProject
    ```

2.  **Создайте файл `.env`:**
    Скопируйте содержимое файла `.env.example` в новый файл `.env` и заполните его своими данными.
    ```bash
    cp .env.example .env
    ```
    Вам необходимо указать как минимум ваш `BOT_TOKEN`, полученный от [@BotFather](https://t.me/BotFather). Остальные значения можно оставить по умолчанию для локального запуска.

3.  **Запустите проект с помощью Docker Compose:**
    Эта команда соберет все образы, создаст контейнеры и запустит их в фоновом режиме.
    ```bash
    docker-compose up --build -d
    ```

4.  **Создайте суперпользователя (опционально):**
    Если вы хотите получить доступ к админ-панели Django, выполните эту команду и следуйте инструкциям в консоли.
    ```bash
    docker-compose exec backend python manage.py createsuperuser
    ```
    Админ-панель будет доступна по адресу `http://localhost:8000/admin/`.

5.  **Настройте периодические уведомления (обязательно):**
    - Зайдите в админ-панель (`http://localhost:8000/admin/`).
    - Перейдите в раздел `Periodic Tasks`.
    - Нажмите `Add Periodic Task`.
    - **Name:** `Check for due tasks every minute`
    - **Task (registered):** Выберите `todos.tasks.check_for_due_tasks` из списка.
    - **Interval:** Создайте новый интервал (1 минута).
    - Убедитесь, что галочка `Enabled` стоит, и сохраните.

6.  **Начните использовать бота:**
    Найдите вашего бота в Telegram и отправьте ему команду `/start`.

## Трудности и их решения

-   **Проблема:** Запрет на использование стандартных механизмов генерации PK (UUID, auto-increment).
    -   **Решение:** Был реализован собственный детерминированный генератор ID в сервисном слое. ID создается путем хеширования (SHA-1) строки, состоящей из ID пользователя, названия объекта и точной временной метки. Это гарантирует уникальность и соответствует требованиям. Переход с `sha256` на `sha1` был необходим для соблюдения ограничения Telegram API на длину `callback_data` (64 байта).

-   **Проблема:** "Гонка состояний" при запуске Docker-контейнеров, когда Celery Beat или API-клиенты стартовали раньше, чем применялись миграции базы данных.
    -   **Решение:** Был внедрен `entrypoint.sh` скрипт для контейнера `backend`. Скрипт сначала ожидает полной готовности базы данных, затем автоматически применяет все необходимые миграции, и только после этого запускает основной процесс (Gunicorn). Это гарантирует правильный порядок инициализации сервисов.

-   **Проблема:** Ошибки `400 Bad Request` при обновлении задач (`is_completed`, `categories`).
    -   **Решение:** Проблема была решена переходом от семантически некорректного `PUT`-запроса (полная замена ресурса) к `PATCH`-запросу (частичное обновление). Это упростило логику на стороне клиента (не нужно отправлять все поля) и соответствует лучшим практикам REST API. Также был настроен `DateTimeField` в сериализаторе для приема разных форматов дат.